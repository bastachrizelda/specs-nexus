from sqlalchemy import Column, Integer, String, Text, DateTime, Float, ForeignKey, Table, Enum, Boolean, UniqueConstraint
import enum
from sqlalchemy.orm import relationship
from .database import Base
from datetime import datetime, timezone, timedelta

try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except Exception:  # pragma: no cover
    ZoneInfo = None  # type: ignore[assignment]
    ZoneInfoNotFoundError = Exception  # type: ignore[assignment]


def _manila_tzinfo():
    """Return tzinfo for Asia/Manila.

    On some Windows/Python installs, the IANA tz database isn't available unless
    the optional `tzdata` package is installed. Manila has no DST, so a fixed
    UTC+8 fallback is correct.
    """

    if ZoneInfo is not None:
        try:
            return ZoneInfo("Asia/Manila")
        except ZoneInfoNotFoundError:
            pass
    return timezone(timedelta(hours=8))


def _to_manila(dt: datetime | None) -> datetime | None:
    if dt is None:
        return None
    # Frontend submits local (Manila) datetimes without timezone info.
    # Treat naive datetimes as Asia/Manila to keep registration windows correct.
    manila_tz = _manila_tzinfo()
    if dt.tzinfo is None:
        return dt.replace(tzinfo=manila_tz)
    return dt.astimezone(manila_tz)

year_enum = Enum('1st Year', '2nd Year', '3rd Year', '4th Year', name='year_enum')

payment_status_enum = Enum('Not Paid', 'Pending', 'Verifying', 'Paid', 'Rejected', name='payment_status')

class EventApprovalStatus(enum.Enum):
    pending = "pending"
    approved = "approved"
    declined = "declined"

event_participants = Table(
    "event_participants",
    Base.metadata,
    Column("event_id", Integer, ForeignKey("events.id"), primary_key=True),
    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True)
)

class CertificateTemplate(Base):
    __tablename__ = "certificate_templates"
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), unique=True)
    template_url = Column(String(500))
    name_x = Column(Integer)
    name_y = Column(Integer)
    font_size = Column(Integer, default=48)
    font_color = Column(String(50), default="#000000")
    font_family = Column(String(100), default="Arial")
    font_weight = Column(String(10), default="400")
    archived = Column(Boolean, default=False)
    event = relationship("Event", back_populates="certificate_template")

class ECertificate(Base):
    __tablename__ = "certificates"
    __table_args__ = (
        UniqueConstraint("user_id", "event_id", name="uq_certificates_user_event"),
    )
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    event_id = Column(Integer, ForeignKey("events.id"))
    certificate_url = Column(String(255))
    thumbnail_url = Column(String(255), nullable=True)
    file_name = Column(String(255))
    issued_date = Column(DateTime)
    certificate_code = Column(String(100), unique=True, index=True)
    event = relationship("Event", back_populates="certificates")
    user = relationship("User", back_populates="certificates")
    
    @property
    def event_title(self):
        """Get event title from the relationship"""
        return self.event.title if self.event else None

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True)
    password = Column(String(255))
    student_number = Column(String(50), unique=True, index=True)
    full_name = Column(String(255))
    year = Column(year_enum, nullable=True)
    block = Column(String(50))
    last_active = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    events_joined = relationship("Event", secondary=event_participants, back_populates="participants")
    clearance = relationship("Clearance", back_populates="user", uselist=False)
    certificates = relationship("ECertificate", back_populates="user")

class Clearance(Base):
    __tablename__ = "clearances"
    __table_args__ = (
        # Prevent re-using the same reference number for the same payment method.
        # Postgres allows multiple NULLs under UNIQUE, so cash/no-ref is fine.
        UniqueConstraint("payment_method", "reference_number", name="uq_clearances_payment_method_reference_number"),
        UniqueConstraint("receipt_number", name="uq_clearances_receipt_number"),
    )

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    requirement = Column(Enum("1st Semester Membership", "2nd Semester Membership", name="clearance_requirement"), nullable=False)
    status = Column(Enum("Clear", "Processing", "Not Yet Cleared", name="clearance_status"), default="Not Yet Cleared", nullable=False)
    payment_status = Column(payment_status_enum, default="Not Paid", nullable=False)
    receipt_path = Column(String(255), nullable=True)
    amount = Column(Float)
    archived = Column(Boolean, default=False)
    payment_method = Column(String(50), nullable=True)
    reference_number = Column(String(100), nullable=True)
    receipt_number = Column(String(100), nullable=True, unique=True)
    denial_reason = Column(String(500), nullable=True)
    payment_date = Column(DateTime, nullable=True)
    approval_date = Column(DateTime, nullable=True)
    approved_by = Column(String(255), nullable=True)
    verified_by = Column(Integer, ForeignKey("officers.id"), nullable=True)
    verified_at = Column(DateTime, nullable=True)
    last_updated = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    user = relationship("User", back_populates="clearance")
    verified_by_officer = relationship("Officer")

class QRCode(Base):
    __tablename__ = "qr_codes"
    id = Column(Integer, primary_key=True, index=True)
    gcash = Column(String(255), nullable=True)
    paymaya = Column(String(255), nullable=True)

class Event(Base):
    __tablename__ = "events"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False)
    description = Column(String(1000))
    date = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    image_url = Column(String(255), nullable=True)
    location = Column(String(255), nullable=True)
    archived = Column(Boolean, default=False)
    registration_start = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    registration_end = Column(DateTime, nullable=True)
    feedback_link = Column(String(500), nullable=True)
    evaluation_open = Column(Boolean, default=False)
    approval_status = Column(Enum(EventApprovalStatus, name='event_approval_status'), default=EventApprovalStatus.pending, nullable=True)
    decline_reason = Column(String(500), nullable=True)
    participants = relationship("User", secondary=event_participants, back_populates="events_joined")
    certificates = relationship("ECertificate", back_populates="event")
    certificate_template = relationship("CertificateTemplate", back_populates="event", uselist=False)

    @property
    def participant_count(self):
        return len(self.participants) if self.participants else 0

    @property
    def registration_open(self):
        now = datetime.now(_manila_tzinfo())
        reg_start = _to_manila(self.registration_start)
        if reg_start and now < reg_start:
            return False
        reg_end = _to_manila(self.registration_end)
        if reg_end and now > reg_end:
            return False
        return True

    @property
    def registration_status(self):
        now = datetime.now(_manila_tzinfo())
        reg_start = _to_manila(self.registration_start)
        if reg_start and now < reg_start:
            return "not_started"
        reg_end = _to_manila(self.registration_end)
        if reg_end and now > reg_end:
            return "closed"
        return "open"

class EventAttendance(Base):
    """Tracks actual attendance (QR scan check-in) for event participants."""
    __tablename__ = "event_attendance"
    __table_args__ = (
        UniqueConstraint("event_id", "user_id", name="uq_event_attendance_event_user"),
    )

    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    checked_in_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    checked_in_by = Column(String(255), nullable=True)  # Officer who scanned the QR
    evaluation_completed = Column(Boolean, default=False)  # Track if user completed evaluation
    evaluation_completed_at = Column(DateTime, nullable=True)  # When evaluation was completed

    event = relationship("Event", backref="attendance_records")
    user = relationship("User", backref="attendance_records")


class Announcement(Base):
    __tablename__ = "announcements"
    id = Column(Integer, primary_key=True)
    title = Column(String(255))
    description = Column(String(1000))
    image_url = Column(String(255), nullable=True)
    location = Column(String(255), nullable=True)
    date = Column(DateTime, nullable=True)
    archived = Column(Boolean, default=False)

class Officer(Base):
    __tablename__ = "officers"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    password = Column(String(255), nullable=False)
    student_number = Column(String(50), unique=True, index=True, nullable=False)
    full_name = Column(String(255), nullable=False)
    year = Column(String(50))
    block = Column(String(50))
    position = Column(String(255))
    archived = Column(Boolean, default=False)